# 谢佳奇排序笔记

### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

按题意，暴力算法为对整个数组升序排序，后返回有序数组length-k索引位元素即为第K大元素。普遍采用快速排序算法对数组排序，时间复杂度为$O(n\log n)$。因手写的快速排序解法效率不高，猜测测试案例中有大量近乎降序排列的测试案例使得快速排序算法时间复杂度退化为$O(n^2)$。

本体可用`减治`方式优化快速排序，即`快速选择`方法。在分治时不对左右两侧递归运算，仅对包含k索引侧进行递归运算。



#### 快速排序小TIPS

##### pivot元素选取方式:

1. 低位索引元素
2. 高位索引元素
3. 中间元素
4. 随机元素

##### 分区过程中交换策略

1. 取最高位元素为pivot，从低位开始遍历
 ```java
	for(int j = lo, i = lo; j<hi;j++){
       if(nums[j]<nums[hi]) 
           swap(nums[i++],nums[j]);
	}
	swap(nums[i],nums[hi]);
 ```

2. 取高位元素为pivot，低位与高位两个临时指针用于元素交换，先从高位向低位找大于pivot元素交换，后切换为从低位向高位找小于pivot元素交换。如此循环至低位与高位标记碰面。



### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

#### 第一眼题思路与问题

按数组元素值与出现频次构成二元组`<value,times>`，生成对二元组按频次排列的新数组，返回其中的第k项（设为降序排列，升序为length-k+1项）。

对整数按数值分桶若题目限定正整数且数值范围不过大（最大值为数组可接受长度）可构建新数组，其中将原值作为索引，实际元素存放出现次数。反转频次数组中的值与索引(map中的k-v对)，对反转后的K-V队按频次排序，输出结果。生成频次复杂度$O(n)$，反转K-V $O(n)$，按频次桶排序$O(n)$(此处频次为数值型，每个桶间隔固定1，比快排等算法效率高)。

> 上面所说实际为桶排序取数组大小个桶的结果。

#### 如何确定有多少个桶？



### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

#### 第一眼思路

对字符数组进行桶排序，26字母大小写取52桶。构成`(C,F)`字母频次队，频次可有两种表现方式，一种为int记录出现次数`char[]`，一种为char链表(标准桶排序方式)`char[][]` `List<Character>[]`。

反转`(C,F)`成`(F,c)`对`char[],排名为索引,值为字符对应的顺序0位a`二元组按频次降序排列，顺序输出。

#### 步骤总结

1. 字符数组放入HashMap构造`<Char,Freq>`对
2. 反转排序`<Freq,Char>`，以数组下标为Freq桶号进行桶排序
3. 逆序输出非空的反转元素 



### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

#### 第一眼思路

三个颜色0、1、2，假设按0、1、2的顺序排列。两次遍历，一次左边置0，一次右边置2。

#### 计数排序

类似于桶排序的方式，对每个元素出现次数计数，后拼接成顺序的列表。

##### 计数排序与桶排序以及哈希映射构建的关系?